# **广播网络实验**

2024年11月13日  

2024E8013282087-陈潇

## 实验内容

**基于已有代码，实现生成树运行机制，对于给定拓扑(four_node_ring.py)，计算输出相应状态下的生成树拓扑**

+ 设计思路
  现有代码框架已解决了STP通信等相关问题，我们需要处理的主要任务是解析收到的包，并根据包中包含的目标端口配置与本端口及其对应节点的配置进行对比，从而更新本端口及本节点的配置。实现这一功能的代码部分将会在代码框架中的`stp_handle_config_packet`函数中完成。  
  
  本设计对应的伪代码如下：
  ```
  // 收到 STP 配置消息时处理
  function handle_stp_config_received(stp_config, port):
      // 比较本端口和发送端口的优先级
      if compare_ports_priority(port, stp_config.sender_port) < 0:  // 本端口优先级较高
          // 更新本端口的 STP 配置
          update_port_config(port, stp_config)

          // 更新本节点的 STP 配置
          update_node_config(stp_config)

          // 更新本节点其他端口的 STP 配置
          for each other_port in node_ports:
              if other_port != port:
                  update_port_config(other_port, stp_config)

          // 如果本节点不再是根节点
          if is_root_node(node) == False:
              // 停止本节点的计时器
              stop_timer(node)

              // 将 STP 配置通过指定端口发出
              send_stp_config(node, stp_config, port)
      else:
          // 本端口的优先级不更高，忽略收到的配置
          return
  ```
  代码如下：
  ```cpp
  #include "base.h"
  #include <stdio.h>
  extern ustack_t *instance;

  void broadcast_packet(iface_info_t *iface, const char *packet, int len)
  {
  	// TODO: broadcast packet 
  	iface_info_t *ifa = NULL;
  	list_for_each_entry(ifa, &instance->iface_list, list){
  		if(ifa->index!=iface->index)
  		{
  			iface_send_packet(ifa,packet,len);
  		}
  	}
  }
  ```

