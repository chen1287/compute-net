# **广播网络实验**

2024年11月13日  

2024E8013282087-陈潇

## 实验内容

**基于已有代码，实现生成树运行机制，对于给定拓扑(four_node_ring.py)，计算输出相应状态下的生成树拓扑**

+ 设计思路
  现有代码框架已解决了STP通信等相关问题，我们需要处理的主要任务是解析收到的包，并根据包中包含的目标端口配置与本端口及其对应节点的配置进行对比，从而更新本端口及本节点的配置。实现这一功能的代码部分将会在代码框架中的`stp_handle_config_packet`函数中完成。  
  
  本设计对应的伪函数实现：
  ```
  // 收到 STP 配置消息时处理
  function handle_stp_config_received(stp_config, port):
      // 比较本端口和发送端口的优先级
      if compare_ports_priority(port, stp_config.sender_port) < 0:  // 本端口优先级较高
          // 更新本端口的 STP 配置
          update_port_config(port, stp_config)

          // 更新本节点的 STP 配置
          update_node_config(stp_config)

          // 更新本节点其他端口的 STP 配置
          for each other_port in node_ports:
              if other_port != port:
                  update_port_config(other_port, stp_config)

          // 如果本节点不再是根节点
          if is_root_node(node) == False:
              // 停止本节点的计时器
              stop_timer(node)

              // 将 STP 配置通过指定端口发出
              send_stp_config(node, stp_config, port)
      else:
          // 本端口的优先级不更高，忽略收到的配置
          return
  ```
  函数实现：
  ```cpp
  #include "base.h"
  #include <stdio.h>
  extern ustack_t *instance;

  void broadcast_packet(iface_info_t *iface, const char *packet, int len)
  {
  	// TODO: broadcast packet 
  	iface_info_t *ifa = NULL;
  	list_for_each_entry(ifa, &instance->iface_list, list){
  		if(ifa->index!=iface->index)
  		{
  			iface_send_packet(ifa,packet,len);
  		}
  	}
  }
  ```
  为了实现上述函数，还需要实现几个子函数，下面对其进行解释：
  `int compare_ports_pirority(stp_port_t * p1, stp_port_t * p2)`
  函数描述：比较当前端口和发送端口的config优先级，当前端口更高返回`0`，发送窗口更高返回`1`。
  函数实现：
  ```cpp
    int compare_ports_pirority(stp_port_t * p1, stp_port_t * p2) {
        if (p1->designated_root != p2->designated_root) {
            if(p1->designated_root < p2->designated_root) {
                return 0;
            } else {
                return 1;
            }
        } else if (p1->designated_cost != p2->designated_cost) {
            if (p1->designated_cost < p2->designated_cost) {
                return 0;
            } else {
                return 1;
            }
        } else if (p1->designated_switch != p2->designated_switch) {
            if (p1->designated_switch < p2->designated_switch) {
                return 0;
            } else {
                return 1;
            }
        } else if (p1->designated_port != p2->designated_port) {
            if (p1->designated_port < p2->designated_port) {
                return 0;
            } else {
                return 1;
            }
        } else {
            return 1;
        }
    }
    ```
  `int recv_has_higher_pirority(stp_port_t * p, struct stp_config *config)`
  函数描述：对接收到的包进行字节时序的转换，然后比较当前端口和发送端口的config优先级，当前端口更高返回`0`，发送窗口更高返回`1`。
  函数实现：
  ```cpp
    int recv_has_higher_pirority(stp_port_t * p, struct stp_config *config) {
        if (p->designated_root != ntohll(config->root_id)) {
            if(p->designated_root < ntohll(config->root_id)) {
                return 0;
            } else {
                return 1;
            }
        } else if (p->designated_cost != ntohl(config->root_path_cost)) {
            if (p->designated_cost < ntohl(config->root_path_cost)) {
                return 0;
            } else {
                return 1;
            }
        } else if (p->designated_switch != ntohll(config->switch_id)) {
            if (p->designated_switch < ntohll(config->switch_id)) {
                return 0;
            } else {
                return 1;
            }
        } else if (p->designated_port != ntohs(config->port_id)) {
            if (p->designated_port < ntohs(config->port_id)) {
                return 0;
            } else {
                return 1;
            }
        } else {
            return 1;
        }
    }
  ```
  `void update_port_config(stp_port_t *p, struct stp_config *config)`
  函数描述：根据接收端口发送的config的值来更新本端口的config，同时将本端口更新为非指定端口。
  函数实现：
  ```cpp
    void update_port_config(stp_port_t *p, struct stp_config *config) {
        p->designated_root = ntohll(config->root_id);
        p->designated_switch = ntohll(config->switch_id);
        p->designated_port = ntohs(config->port_id);
        p->designated_cost = ntohl(config->root_path_cost);
    }
  ```
  `void update_root(stp_t *stp, struct stp_config *config)`
  函数描述：更新节点的状态，先遍历所有端口找出根端口，如果不存在根端口则把当前节点设置为根端口。再通过root_port连接到根节点，更新节点状态。
  `void update_other_ports(stp_t *stp)`
  函数描述：对于所有指定端口，更新其认为的根节点和路径开销。
  函数实现：
  ```cpp
    void update_other_ports(stp_t *stp) {
        for (int i =0 ; i < stp->nports; i++) {
            if(stp_port_is_designated(&stp->ports[i])) {
                stp->ports[i].designated_root = stp->designated_root;
                stp->ports[i].designated_cost = stp->root_path_cost;
            }
        }
    }
  ```

